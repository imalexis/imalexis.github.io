"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8081],{6293:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var i=t(5893),a=t(1151);const r={title:"Implemenation of a Heap",description:"This is my first post on Docusaurus.",slug:"heap",tags:["data structure"],hide_table_of_contents:!1},l=void 0,o={permalink:"/blog/heap",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/heap/heap.md",source:"@site/blog/heap/heap.md",title:"Implemenation of a Heap",description:"This is my first post on Docusaurus.",date:"2023-12-29T05:20:32.838Z",formattedDate:"December 29, 2023",tags:[{label:"data structure",permalink:"/blog/tags/data-structure"}],readingTime:3.51,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Implemenation of a Heap",description:"This is my first post on Docusaurus.",slug:"heap",tags:["data structure"],hide_table_of_contents:!1},unlisted:!1,nextItem:{title:"Welcome",permalink:"/blog/welcome"}},p={authorsImageUrls:[]},s=[{value:"Min Heap",id:"min-heap",level:3}];function d(e){const n={code:"code",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"min-heap",children:"Min Heap"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Complete binary tree"}),"\n",(0,i.jsx)(n.li,{children:"Each node in the Heap has a value no larger than its child nodes. Therefore, the top element (root node) has the smallest value in the Heap."}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.p,{children:"transform a binary tree into an array"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Tree To Array",src:t(636).Z+"",width:"838",height:"575"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'// Implementing "Min Heap"\npublic class MinHeap {\n    // Create a complete binary tree using an array\n    // Then use the binary tree to construct a Heap\n    int[] minHeap;\n    // the number of elements is needed when instantiating an array\n    // heapSize records the size of the array\n    int heapSize;\n    // realSize records the number of elements in the Heap\n    int realSize = 0;\n\n    public MinHeap(int heapSize) {\n        this.heapSize = heapSize;\n        minHeap = new int[heapSize + 1];\n        // To better track the indices of the binary tree, \n        // we will not use the 0-th element in the array\n        // You can fill it with any value\n        minHeap[0] = 0;\n    }\n\n    // Function to add an element\n    public void add(int element) {\n        realSize++;\n        // If the number of elements in the Heap exceeds the preset heapSize\n        // print "Added too many elements" and return\n        if (realSize > heapSize) {\n            System.out.println("Added too many elements!");\n            realSize--;\n            return;\n        }\n        // Add the element into the array\n        minHeap[realSize] = element;\n        // Index of the newly added element\n        int index = realSize;\n        // Parent node of the newly added element\n        // Note if we use an array to represent the complete binary tree\n        // and store the root node at index 1\n        // index of the parent node of any node is [index of the node / 2]\n        // index of the left child node is [index of the node * 2]\n        // index of the right child node is [index of the node * 2 + 1]\n        int parent = index / 2;\n        // If the newly added element is smaller than its parent node,\n        // its value will be exchanged with that of the parent node \n        while ( minHeap[index] < minHeap[parent] && index > 1 ) {\n            int temp = minHeap[index];\n            minHeap[index] = minHeap[parent];\n            minHeap[parent] = temp;\n            index = parent;\n            parent = index / 2;\n        }\n    }\n\n    // Get the top element of the Heap\n    public int peek() {\n        return minHeap[1];\n    }\n\n    // Delete the top element of the Heap\n    public int pop() {\n        // If the number of elements in the current Heap is 0,\n        // print "Don\'t have any elements" and return a default value\n        if (realSize < 1) {\n            System.out.println("Don\'t have any element!");\n            return Integer.MAX_VALUE;\n        } else {\n            // When there are still elements in the Heap\n            // realSize >= 1\n            int removeElement = minHeap[1];\n            // Put the last element in the Heap to the top of Heap\n            minHeap[1] = minHeap[realSize];\n            realSize--;\n            int index = 1;\n            // When the deleted element is not a leaf node\n            while (index <= realSize / 2) {\n                // the left child of the deleted element\n                int left = index * 2;\n                // the right child of the deleted element\n                int right = (index * 2) + 1;\n                // If the deleted element is larger than the left or right child\n                // its value needs to be exchanged with the smaller value\n                // of the left and right child\n                if (minHeap[index] > minHeap[left] || minHeap[index] > minHeap[right]) {\n                    if (minHeap[left] < minHeap[right]) {\n                        int temp = minHeap[left];\n                        minHeap[left] = minHeap[index];\n                        minHeap[index] = temp;\n                        index = left;\n                    } else {\n                        // maxHeap[left] >= maxHeap[right]\n                        int temp = minHeap[right];\n                        minHeap[right] = minHeap[index];\n                        minHeap[index] = temp;\n                        index = right;\n                    }\n                } else {\n                    break;\n                }\n            }\n            return removeElement;\n        } \n    }\n\n    // return the number of elements in the Heap\n    public int size() {\n        return realSize;\n    }\n\n    public String toString() {\n        if (realSize == 0) {\n            return "No element!";\n        } else {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\'[\');\n            for (int i = 1; i <= realSize; i++) {\n                sb.append(minHeap[i]);\n                sb.append(\',\');\n            }\n            sb.deleteCharAt(sb.length() - 1);\n            sb.append(\']\');\n            return sb.toString();\n        }\n    }\n\n    public static void main(String[] args) {\n        // Test case\n        MinHeap minHeap = new MinHeap(3);\n        minHeap.add(3);\n        minHeap.add(1);\n        minHeap.add(2);\n        // [1,3,2]\n        System.out.println(minHeap.toString());\n        // 1\n        System.out.println(minHeap.peek());\n        // 1\n        System.out.println(minHeap.pop());\n        // [2, 3]\n        System.out.println(minHeap.toString());\n        minHeap.add(4);\n        // Add too many elements\n        minHeap.add(5);\n        // [2,3,4]\n        System.out.println(minHeap.toString());\n    }\n}\n\n'})})]})}function m(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},636:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/TreeToArray-b0eb5c06de60ce8a5e9fbd613b8d9102.png"},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>l});var i=t(7294);const a={},r=i.createContext(a);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);